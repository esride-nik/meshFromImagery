import{an as on,e_ as T,db as y,e$ as Y,f0 as rn,f1 as A,f2 as cn,d8 as u,f3 as un,f4 as F,d1 as l,f5 as o,d2 as p,f6 as P,f7 as fn,f8 as gn,f9 as bn,fa as I,fb as ln,fc as pn,fd as dn,fe as h,ff as $n,fg as hn,fh as H,fi as In,fj as G,fk as q,fl as N,fm as mn,fn as V,fo as Pn,fp as Nn,fq as $,fr as v,fs as Mn,ft as vn,fu as O,fv as R,fw as W,aW as M,fx as L}from"./index-b516d057.js";const j=on.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class wn{constructor(){this.plane=T(),this.origin=M(),this.basis1=M(),this.basis2=M()}}const Tn=wn;function m(n=tn){return{plane:T(n.plane),origin:A(n.origin),basis1:A(n.basis1),basis2:A(n.basis2)}}function _n(n,i,s){const a=zn.get();return a.origin=n,a.basis1=i,a.basis2=s,a.plane=cn(0,0,0,0),S(a),a}function _(n,i=m()){return Q(n.origin,n.basis1,n.basis2,i)}function Sn(n,i){u(i.origin,n.origin),u(i.basis1,n.basis1),u(i.basis2,n.basis2),un(i.plane,n.plane)}function Q(n,i,s,a=m()){return u(a.origin,n),u(a.basis1,i),u(a.basis2,s),S(a),Un(a,"fromValues()"),a}function S(n){F(n.basis2,n.basis1,n.origin,n.plane)}function X(n,i,s){n!==s&&_(n,s);const a=l(o.get(),b(n),i);return p(s.origin,s.origin,a),s.plane[3]-=i,s}function xn(n,i,s){return Z(i,s),X(s,k(n,n.origin),s),s}function Z(n,i=m()){const s=(n[2]-n[0])/2,a=(n[3]-n[1])/2;return P(i.origin,n[0]+s,n[1]+a,0),P(i.basis1,s,0,0),P(i.basis2,0,a,0),fn(0,0,1,0,i.plane),i}function B(n,i,s){return!!gn(n.plane,i,s)&&an(n,s)}function yn(n,i,s){if(B(n,i,s))return s;const a=J(n,i,o.get());return p(s,i.origin,l(o.get(),i.direction,bn(i.origin,a)/I(i.direction))),s}function J(n,i,s){const a=w.get();en(n,i,a,w.get());let e=Number.POSITIVE_INFINITY;for(const t of C){const r=z(n,t,x.get()),f=o.get();if(ln(a,r,f)){const c=pn(o.get(),i.origin,f),g=Math.abs(dn(h(i.direction,c)));g<e&&(e=g,u(s,f))}}return e===Number.POSITIVE_INFINITY?K(n,i,s):s}function K(n,i,s){if(B(n,i,s))return s;const a=w.get(),e=w.get();en(n,i,a,e);let t=Number.POSITIVE_INFINITY;for(const r of C){const f=z(n,r,x.get()),c=o.get();if($n(a,f,c)){const g=hn(i,c);if(!H(e,c))continue;g<t&&(t=g,u(s,c))}}return U(n,i.origin)<t&&nn(n,i.origin,s),s}function nn(n,i,s){const a=In(n.plane,i,o.get()),e=G(D(n,n.basis1),a,-1,1,o.get()),t=G(D(n,n.basis2),a,-1,1,o.get());return q(s,p(o.get(),e,t),n.origin),s}function sn(n,i,s){const{origin:a,basis1:e,basis2:t}=n,r=q(o.get(),i,a),f=N(e,r),c=N(t,r),g=N(b(n),r);return P(s,f,c,g)}function U(n,i){const s=sn(n,i,o.get()),{basis1:a,basis2:e}=n,t=I(a),r=I(e),f=Math.max(Math.abs(s[0])-t,0),c=Math.max(Math.abs(s[1])-r,0),g=s[2];return f*f+c*c+g*g}function An(n,i){return Math.sqrt(U(n,i))}function Vn(n,i){let s=Number.NEGATIVE_INFINITY;for(const a of C){const e=z(n,a,x.get()),t=mn(e,i);t>s&&(s=t)}return Math.sqrt(s)}function On(n,i){return H(n.plane,i)&&an(n,i)}function jn(n,i,s,a){return Bn(n,s,a)}function k(n,i){const s=-n.plane[3];return N(b(n),i)-s}function En(n,i,s,a){const e=k(n,i),t=l(kn,b(n),s-e);return p(a,i,t),a}function Fn(n,i){return V(n.basis1,i.basis1)&&V(n.basis2,i.basis2)&&V(n.origin,i.origin)}function Yn(n,i,s){return n!==s&&_(n,s),Pn(d,i),Nn(d,d),$(s.basis1,n.basis1,d),$(s.basis2,n.basis2,d),$(v(s.plane),v(n.plane),d),$(s.origin,n.origin,i),Mn(s.plane,s.plane,s.origin),s}function qn(n,i,s,a){return n!==a&&_(n,a),vn(E,i,s),$(a.basis1,n.basis1,E),$(a.basis2,n.basis2,E),S(a),a}function b(n){return v(n.plane)}function Bn(n,i,s){switch(i){case O.X:u(s,n.basis1),R(s,s);break;case O.Y:u(s,n.basis2),R(s,s);break;case O.Z:u(s,b(n))}return s}function an(n,i){const s=q(o.get(),i,n.origin),a=W(n.basis1),e=W(n.basis2),t=h(n.basis1,s),r=h(n.basis2,s);return-t-a<0&&t-a<0&&-r-e<0&&r-e<0}function D(n,i){const s=x.get();return u(s.origin,n.origin),u(s.vector,i),s}function z(n,i,s){const{basis1:a,basis2:e,origin:t}=n,r=l(o.get(),a,i.origin[0]),f=l(o.get(),e,i.origin[1]);p(s.origin,r,f),p(s.origin,s.origin,t);const c=l(o.get(),a,i.direction[0]),g=l(o.get(),e,i.direction[1]);return l(s.vector,p(c,c,g),2),s}function Un(n,i){Math.abs(h(n.basis1,n.basis2)/(I(n.basis1)*I(n.basis2)))>1e-6&&j.warn(i,"Provided basis vectors are not perpendicular"),Math.abs(h(n.basis1,b(n)))>1e-6&&j.warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-h(b(n),n.origin)-n.plane[3])>1e-6&&j.warn(i,"Plane offset is not consistent with plane origin")}function en(n,i,s,a){const e=b(n);F(e,i.direction,i.origin,s),F(v(s),e,i.origin,a)}const tn={plane:T(),origin:y(0,0,0),basis1:y(1,0,0),basis2:y(0,1,0)},w=new Y(T),x=new Y(rn),kn=M(),zn=new Y(()=>m()),C=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=L(),E=L(),Gn=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:Tn,altitudeAt:k,axisAt:jn,closestPoint:K,closestPointOnSilhouette:J,copy:_,copyWithoutVerify:Sn,create:m,distance:An,distance2:U,distanceToSilhouette:Vn,elevate:X,equals:Fn,extrusionContainsPoint:On,fromAABoundingRect:Z,fromValues:Q,intersectRay:B,intersectRayClosestSilhouette:yn,normal:b,projectPoint:nn,projectPointLocal:sn,rotate:qn,setAltitudeAt:En,setExtent:xn,transform:Yn,up:tn,updateUnboundedPlane:S,wrap:_n},Symbol.toStringTag,{value:"Module"}));export{Z as $,Tn as G,Q as H,S as J,m as W,_ as Z,Gn as _,An as a,b as d,Yn as l,qn as m,Fn as p,B as s,On as u};

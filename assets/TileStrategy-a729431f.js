import{a5 as P,a6 as x,a9 as K,bA as L,b9 as A,l6 as B,kc as N,bj as R,kk as Y}from"./index-b516d057.js";import{_ as G}from"./QueueProcessor-4b9d43d3.js";import{l as j}from"./TileInfoView-ce4d65fb.js";import{e as Q}from"./TileKey-4b1303ff.js";function W(r,e){return r.length=0,e.forEach(s=>r.push(s)),r}const V=new Set,b=[],w=new Map,$=[0,0];let m=class extends L{constructor(r){super(r),this._keyToItem=new Map,this.concurrency=6,this.strategy="scale-first",this.tileInfoView=null}initialize(){const{concurrency:r,process:e,strategy:s}=this;this._queue=new G({concurrency:r,process:(i,t)=>{const l=this._keyToItem.get(i);return e(l,{signal:t})},peeker:s==="scale-first"?i=>this._peekByScaleFirst(i):i=>this._peekByCenterFirst(i)})}destroy(){this.clear(),this._queue=A(this._queue)}get length(){return this._queue?this._queue.length:0}get onGoingCount(){return this._keyToItem.size}abort(r){const e=typeof r=="string"?r:r.id;this._queue.abort(e)}clear(){this._queue.clear(),this._keyToItem.clear()}has(r){return typeof r=="string"?this._keyToItem.has(r):this._keyToItem.has(r.id)}isOngoing(r){const e=typeof r=="string"?r:r.id;return this.has(e)&&this._queue.isOngoing(e)}pause(){this._queue.pause()}push(r){const e=r.key.id;if(this._queue.has(e))return this._queue.get(e);const s=this._queue.push(e),i=()=>{this._keyToItem.delete(e)};return this._keyToItem.set(e,r),s.then(i,i),s}reset(){this._queue.reset()}resume(){this._queue.resume()}_peekByScaleFirst(r){if(!this.state)return r.values().next().value;const e=this.tileInfoView;let s=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY;r.forEach(h=>{const o=this._keyToItem.get(h),a=this.tileInfoView.getTileScale(o.key);w.has(a)||(w.set(a,[]),s=Math.max(a,s),i=Math.min(a,i)),w.get(a).push(o.key),V.add(a)});let t=this.state.scale;w.has(t)||(W(b,V),b.sort((h,o)=>h-o),t=b.reduce((h,o)=>Math.abs(o-t)<Math.abs(h-t)?o:h,b[0])),t=Math.min(t,s),t=Math.max(t,i);const l=w.get(t),u=e.getClosestInfoForScale(t),c=u.getColumnForX(this.state.center[0]),f=u.getRowForY(this.state.center[1]);return l.sort((h,o)=>{const a=u.denormalizeCol(h.col,h.world),d=u.denormalizeCol(o.col,o.world);return Math.sqrt((c-a)*(c-a)+(f-h.row)*(f-h.row))-Math.sqrt((c-d)*(c-d)+(f-o.row)*(f-o.row))}),V.clear(),w.clear(),l[0].id}_peekByCenterFirst(r){if(!this.state)return r.values().next().value;const e=this.tileInfoView,s=this.state.center;let i,t=Number.POSITIVE_INFINITY;return r.forEach(l=>{const u=this._keyToItem.get(l);e.getTileCoords($,u.key);const c=B($,s);c<t&&(t=c,i=u.key)}),i.id}};P([x({constructOnly:!0})],m.prototype,"concurrency",void 0),P([x({constructOnly:!0})],m.prototype,"process",void 0),P([x()],m.prototype,"state",void 0),P([x({constructOnly:!0})],m.prototype,"strategy",void 0),P([x({constructOnly:!0})],m.prototype,"tileInfoView",void 0),m=P([K("esri.views.2d.tiling.TileQueue")],m);const Z=m;class X{constructor(e,s,i){this.maxSize=e,this._tileInfoView=s,this._removedFunc=i,this._tilePerId=new Map,this._tileKeysPerLevel=[]}clear(){this._tilePerId.clear(),this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const s=this._tilePerId.get(e);if(!s)return;const i=s.key.level,t=this._tileKeysPerLevel[i];E(this._tilePerId,e);for(let l=0;l<t.length;l++)if(t[l].id===e){t.splice(l,1);break}return s.visible=!0,s}add(e){e.visible=!1;const s=e.key,i=s.id;if(this._tilePerId.has(i))return;this._tilePerId.set(i,e);const t=s.level;this._tileKeysPerLevel[t]||(this._tileKeysPerLevel[t]=[]),this._tileKeysPerLevel[t].push(s)}prune(e,s,i){let t=this._tilePerId.size;if(t<=this.maxSize)return;let l=this._tileKeysPerLevel.length-1;for(;t>this.maxSize&&l>=0;)l!==e&&(t=this._pruneAroundCenterTile(t,s,i,l)),l--;t>this.maxSize&&(t=this._pruneAroundCenterTile(t,s,i,e))}_pruneAroundCenterTile(e,s,i,t){const l=this._tileKeysPerLevel[t];if(!l||l.length===0)return e;const{size:u,origin:c}=this._tileInfoView.tileInfo,f=i*u[0],h=i*u[1],o=[0,0],a=[0,0];for(l.sort((d,I)=>(o[0]=c.x+f*(d.col+.5),o[1]=c.y-h*(d.row+.5),a[0]=c.x+f*(I.col+.5),a[1]=c.y-h*(I.row+.5),N(o,s)-N(a,s)));l.length>0;){const d=l.pop();if(this._removeTile(d.id),--e===this.maxSize)break}return e}_removeTile(e){const s=this._tilePerId.get(e);this._removedFunc&&s&&this._removedFunc(s),E(this._tilePerId,e)}}function E(r,e){r.delete(e)}const T=new Q(0,0,0,0),p=new Map,k=[],q=[];class ee{constructor(e){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=e.acquireTile,this.releaseTile=e.releaseTile,this.tileInfoView=e.tileInfoView,e.resampling!=null&&(this.resampling=e.resampling),e.cachePolicy&&(this.cachePolicy=e.cachePolicy),e.coveragePolicy&&(this.coveragePolicy=e.coveragePolicy),e.buffer!=null&&(this.buffer=e.buffer),e.cacheSize&&(this._tileCache=new X(e.cacheSize,this.tileInfoView,s=>{this.releaseTile(s)}))}destroy(){this.tileIndex.clear()}update(e){var F,M;const{resampling:s,tileIndex:i}=this,{scale:t,center:l,resolution:u}=e.state,{minScale:c,maxScale:f}=this.tileInfoView,h=!e.stationary&&t>this._previousScale;if(this._previousScale=t,!s&&(t>c||t<f))return this.tiles.length=0,void this.clear();const o=this.tileInfoView.getTileCoverage(e.state,this.buffer,this.resampling,this.coveragePolicy);if(!o)return this.tiles.length=0,void this.clear();const{spans:a,lodInfo:d}=o,{level:I}=d;this.tiles.length=0,i.forEach(n=>n.visible=!0);let z=0,S=0;if(a.length>0)for(const{row:n,colFrom:v,colTo:C}of a)for(let g=v;g<=C;g++){z++;const y=T.set(I,n,d.normalizeCol(g),d.getWorldForColumn(g)).id;let _=i.get(y);if(_)_.isReady?(p.set(y,_),S++):h||this._addParentTile(y,p);else{if((F=this._tileCache)!=null&&F.has(y)){if(_=this._tileCache.pop(y),this.tileIndex.set(y,_),_.isReady){p.set(y,_),S++;continue}}else _=this.acquireTile(T),this.tileIndex.set(y,_);h||this._addParentTile(y,p)}}const O=S===z;for(const[n,v]of i){if(p.has(n))continue;T.set(n);const C=this.tileInfoView.intersects(o,T),g=this.cachePolicy==="purge"?T.level!==I:T.level>I;!C||!h&&O?!g&&C||k.push(v):v.isReady?g&&this.cachePolicy==="purge"&&this._hasReadyAncestor(T,I)?k.push(v):q.push(v):g&&k.push(v)}for(const n of q)n.isReady&&p.set(n.key.id,n);for(const n of k)this._tileCache?this._tileCache.add(n):this.releaseTile(n),i.delete(n.key.id);for(const n of p.values())this.tiles.push(n);for(const n of i.values())p.has(n.key.id)||(n.visible=!1);(M=this._tileCache)==null||M.prune(I,l,u),j.pool.release(o),q.length=0,k.length=0,p.clear()}clear(){const{tileIndex:e}=this;for(const s of e.values())this.releaseTile(s);e.clear()}refresh(e){var s;for(const i of this.tileIndex.values())this.tiles.includes(i)?e(i):k.push(i);for(const i of k)this.releaseTile(i),this.tileIndex.delete(i.key.id);(s=this._tileCache)==null||s.clear()}updateCacheSize(e){this._tileCache&&(this._tileCache.maxSize=e)}_addParentTile(e,s){var l;let i=e,t=null;for(;i=this.tileInfoView.getTileParentId(i),i;)if(this.tileIndex.has(i)){if(t=this.tileIndex.get(i),t==null?void 0:t.isReady){s.has(t.key.id)||s.set(t.key.id,t);break}}else if((l=this._tileCache)!=null&&l.has(i)&&(t=this._tileCache.pop(i),this.tileIndex.set(i,t),t==null?void 0:t.isReady)){s.has(t.key.id)||s.set(t.key.id,t);break}}_hasReadyAncestor(e,s){const i=R();this.tileInfoView.getTileBounds(i,e,!0);for(const t of this.tileIndex.values())if(t.isReady&&t.key.level>=s&&t.key.level<e.level){const l=R();if(this.tileInfoView.getTileBounds(l,t.key,!0),Y(l,i))return!0}return!1}}export{ee as r,Z as y};

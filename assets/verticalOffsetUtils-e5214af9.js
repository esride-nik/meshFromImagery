import{aW as m,d9 as q,fa as _,f6 as O,fD as p,fE as b,fF as d,fG as B,fH as G,fq as x,fx as v,fo as D,fp as L,fI as E,fJ as H,fB as V,fK as S,d2 as k}from"./index-b516d057.js";import{l as C}from"./ViewingMode-5d7d590b.js";import{H as F,e as J}from"./orientedBoundingBox-67c5cd22.js";class Y{constructor(){this._transform=v(),this._transformInverse=new T({value:this._transform},D,v),this._transformInverseTranspose=new T(this._transformInverse,L,v),this._transformTranspose=new T({value:this._transform},L,v),this._transformInverseRotation=new T({value:this._transform},E,H)}_invalidateLazyTransforms(){this._transformInverse.invalidate(),this._transformInverseTranspose.invalidate(),this._transformTranspose.invalidate(),this._transformInverseRotation.invalidate()}get transform(){return this._transform}get inverse(){return this._transformInverse.value}get inverseTranspose(){return this._transformInverseTranspose.value}get inverseRotation(){return this._transformInverseRotation.value}get transpose(){return this._transformTranspose.value}setTransformMatrix(t){V(this._transform,t)}multiplyTransform(t){S(this._transform,this._transform,t)}set(t){V(this._transform,t),this._invalidateLazyTransforms()}setAndInvalidateLazyTransforms(t,e){this.setTransformMatrix(t),this.multiplyTransform(e),this._invalidateLazyTransforms()}}class T{constructor(t,e,r){this._original=t,this._update=e,this._dirty=!0,this._transform=r()}invalidate(){this._dirty=!0}get value(){return this._dirty&&(this._update(this._transform,this._original.value),this._dirty=!1),this._transform}}class K{constructor(t=0){this.offset=t,this.tmpVertex=m()}applyToVertex(t,e,r){const i=O(g,t,e,r),n=k(y,i,this.localOrigin),a=this.offset/_(n);return p(this.tmpVertex,i,n,a),this.tmpVertex}applyToAabb(t){const e=z,r=A,i=R;for(let s=0;s<3;++s)e[s]=t[0+s]+this.localOrigin[s],r[s]=t[3+s]+this.localOrigin[s],i[s]=e[s];const n=this.applyToVertex(e[0],e[1],e[2]);for(let s=0;s<3;++s)t[s]=n[s],t[s+3]=n[s];const a=s=>{const o=this.applyToVertex(s[0],s[1],s[2]);for(let l=0;l<3;++l)t[l]=Math.min(t[l],o[l]),t[l+3]=Math.max(t[l+3],o[l])};for(let s=1;s<8;++s){for(let o=0;o<3;++o)i[o]=s&1<<o?r[o]:e[o];a(i)}let h=0;for(let s=0;s<3;++s)e[s]*r[s]<0&&(h|=1<<s);if(h!==0&&h!==7){for(let s=0;s<8;++s)if(!(h&s)){for(let o=0;o<3;++o)i[o]=h&1<<o?0:s&1<<o?e[o]:r[o];a(i)}}for(let s=0;s<3;++s)t[s]-=this.localOrigin[s],t[s+3]-=this.localOrigin[s];return t}}class W{constructor(t=0){this.componentLocalOriginLength=0,this._tmpVertex=m(),this._mbs=q(),this._obb=F(),this._totalOffset=0,this._offset=0,this._resetOffset(t)}_resetOffset(t){this._offset=t,this._totalOffset=t}set offset(t){this._resetOffset(t)}get offset(){return this._offset}set componentOffset(t){this._totalOffset=this._offset+t}set localOrigin(t){this.componentLocalOriginLength=_(t)}applyToVertex(t,e,r){const i=O(g,t,e,r),n=O(y,t,e,r+this.componentLocalOriginLength),a=this._totalOffset/_(n);return p(this._tmpVertex,i,n,a),this._tmpVertex}applyToAabb(t){const e=O(g,t[0],t[1],t[2]+this.componentLocalOriginLength),r=O(y,t[3],t[4],t[5]+this.componentLocalOriginLength),i=b(z,e),n=b(A,r),a=d(R,e),h=d(P,r),s=B(w,a,h);s[0]=i[0]*n[0]<0?0:s[0],s[1]=i[1]*n[1]<0?0:s[1],s[2]=i[2]*n[2]<0?0:s[2];const o=_(s);if(o<this._totalOffset)return t[0]-=e[0]<0?this._totalOffset:0,t[1]-=e[1]<0?this._totalOffset:0,t[2]-=e[2]<0?this._totalOffset:0,t[3]+=r[0]>0?this._totalOffset:0,t[4]+=r[1]>0?this._totalOffset:0,t[5]+=r[2]>0?this._totalOffset:0,t;const l=G(w,a,h),j=_(l),c=this._totalOffset/j,u=this._totalOffset/o;return t[0]+=e[0]*(e[0]>0?c:u),t[1]+=e[1]*(e[1]>0?c:u),t[2]+=e[2]*(e[2]>0?c:u),t[3]+=r[0]*(r[0]<0?c:u),t[4]+=r[1]*(r[1]<0?c:u),t[5]+=r[2]*(r[2]<0?c:u),t}applyToMbs(t){const e=_(t),r=this._totalOffset/e;return p(this._mbs,t,t,r),this._mbs[3]=t[3]+t[3]*this._totalOffset/e,this._mbs}applyToObb(t){return J(t,this._totalOffset,this._totalOffset,C.Global,this._obb),this._obb}}class N{constructor(t=0){this.offset=t,this.sphere=q(),this.tmpVertex=m()}applyToVertex(t,e,r){const i=this.objectTransform.transform,n=O(g,t,e,r),a=x(n,n,i),h=this.offset/_(a);p(a,a,a,h);const s=this.objectTransform.inverse;return x(this.tmpVertex,a,s),this.tmpVertex}applyToMinMax(t,e){const r=this.offset/_(t);p(t,t,t,r);const i=this.offset/_(e);p(e,e,e,i)}applyToAabb(t){const e=this.offset/Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]+=t[0]*e,t[1]+=t[1]*e,t[2]+=t[2]*e;const r=this.offset/Math.sqrt(t[3]*t[3]+t[4]*t[4]+t[5]*t[5]);return t[3]+=t[3]*r,t[4]+=t[4]*r,t[5]+=t[5]*r,t}applyToBoundingSphere(t){const e=_(t),r=this.offset/e;return p(this.sphere,t,t,r),this.sphere[3]=t[3]+t[3]*this.offset/e,this.sphere}}const I=new N;function Z(f){return f!=null?(I.offset=f,I):null}const $=new W;function tt(f){return f!=null?($.offset=f,$):null}const M=new K;function st(f){return f!=null?(M.offset=f,M):null}const et="terrain",g=m(),y=m(),z=m(),A=m(),R=m(),P=m(),w=m();export{et as A,Z as I,tt as w,Y as y,st as z};

import{al as T,a5 as C,a9 as F,hk as R,kr as w,y as b,ah as K,aB as E}from"./index-b516d057.js";import{i as P}from"./cimAnalyzer-ce1886a0.js";import{p as $}from"./visualVariablesUtils-b310591f.js";import{S as L}from"./enums-b1d611e3.js";import{x as A,o as I,a as O,E as U,n as B}from"./Matcher-fcb8339d.js";import{p as z}from"./BaseProcessor-a3635281.js";import"./fontUtils-56b88a2f.js";import"./BidiEngine-9a40f2f4.js";import"./labelPoint-96433514.js";import"./OptimizedGeometry-196224d4.js";import"./GeometryUtils-984e8446.js";import"./enums-f1a6a48a.js";import"./alignmentUtils-ae955d28.js";import"./definitions-5366d472.js";import"./mat2d-d4af8487.js";import"./mat2df32-fb26a8c9.js";import"./vec2f32-eaf29605.js";import"./number-e491b09e.js";import"./Rect-ea14f53a.js";import"./callExpressionWithFeature-36423058.js";import"./quantizationUtils-17105106.js";import"./floatRGBA-ca990bbb.js";import"./color-a1c19855.js";import"./enums-bdecffa2.js";import"./VertexElementDescriptor-2925c6af.js";import"./TileInfoView-ce4d65fb.js";import"./TileKey-4b1303ff.js";import"./TileStrategy-a729431f.js";import"./QueueProcessor-4b9d43d3.js";import"./signal-51ed66f5.js";import"./tileUtils-c2f19f52.js";import"./TurboLine-a90259bc.js";import"./MaterialKey-96278cae.js";import"./defaultsJSON-59981e75.js";import"./GeometryUtils-dd03fc25.js";import"./ExpandedCIM-76245323.js";class H{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,r){const s=this._resourceMap,i=s.get(e);if(i)return i;let o=this._inFlightResourceMap.get(e);if(o)return o;try{o=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...r}),this._inFlightResourceMap.set(e,o),o.then(a=>(this._inFlightResourceMap.delete(e),s.set(e,a),a))}catch(a){return T(a)?null:{width:0,height:0}}return o}getResource(e){return this._resourceMap.get(e)??null}loadFont(e){return Promise.resolve(null)}}function k(t,e){const r=e-e/4,s=e+e/2;return(!t.minScale||t.minScale>=r)&&(!t.maxScale||t.maxScale<=s)}function x(t){var s;const e=t.message,r={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin,version:e.version},transferList:new Array};for(const i in e.data){const o=i,a=e.data[o];if(r.message.data[o]=null,a!=null){const c=a.stride,n=a.indices.slice(0),h=a.vertices.slice(0),l=a.records.slice(0),m=(s=a.metrics)==null?void 0:s.slice(0),u={stride:c,indices:n,vertices:h,records:l,metrics:m};r.transferList.push(n,h,l),r.message.data[o]=u}}return r}let S=class extends z{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.addHandles([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new H(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach(e=>{e.forEach(t)})}async update(t,e){var i;const r=e.schema.processors[0];if(r.type!=="symbol")return;const s=R(this._schema,r);(w(s,"mesh")||w(s,"target"))&&(t.mesh=!0,(i=t.why)==null||i.mesh.push("Symbology changed"),this._schema=r,this._factory=this._createFactory(r),this._factory.update(r,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,r,s){return b(s),this._onTileData(t,e,r,s)}onTileClear(t,e){const r={clear:!0,end:e};return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:r})}onTileError(t,e,r){const s=r.signal,i={tileKey:t.id,error:e};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:s})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach(r=>{for(const s of r)s.message.tileKey===e.id&&this._updateTileMesh("append",e,x(s),[],!1,!1,null)})}_addBufferData(t,e){var r;this._bufferData.has(t)||this._bufferData.set(t,[]),(r=this._bufferData.get(t))==null||r.push(x(e))}_createFactory(t){const{geometryType:e,objectIdField:r,fields:s}=this.service,i=(h,l)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",h,l),o={geometryType:e,fields:s,spatialReference:K.fromJSON(this.spatialReference)},a=new A(i,this.tileStore.tileScheme.tileInfo),{matcher:c,aggregateMatcher:n}=t.mesh;return this._store=a,this._matchers.feature=I(c,a,o,this._resourceManagerProxy),this._matchers.aggregate=n?I(n,a,o,this._resourceManagerProxy):null,new O(e,r,a)}async _onTileData(t,e,r,s){var m;b(s);const{type:i,addOrUpdate:o,remove:a,clear:c,end:n}=e,h=!!this._schema.mesh.sortKey;if(!o){const u={type:i,addOrUpdate:null,remove:a,clear:c,end:n,sort:h};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:u},s)}const l=this._processFeatures(t,o,r,s,(m=e.status)==null?void 0:m.version);try{const u=await l;if(u==null){const d={type:i,addOrUpdate:null,remove:a,clear:c,end:n,sort:h};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:d},s)}const f=[];for(const d of u){let p=!1;const g=d.message.bufferIds,y=t.key.id,M=d.message.tileKey;if(y!==M&&g!=null){if(!this.tileStore.get(M)){this._addBufferData(y,d),f.push(d);continue}let _=this._bufferIds.get(M);_||(_=new Set,this._bufferIds.set(M,_));const D=Array.from(g);for(const v of D){if(_.has(v)){p=!0;break}_.add(v)}}p||(this._addBufferData(y,d),f.push(d))}await Promise.all(f.map(d=>{const p=t.key.id===d.message.tileKey,g=p?e.remove:[],y=p&&e.end;return this._updateTileMesh(i,t,d,g,y,!!e.clear,s.signal)}))}catch(u){this._handleError(t,u,s)}}async _updateTileMesh(t,e,r,s,i,o,a){const c=t,n=r.message.tileKey,h=!!this._schema.mesh.sortKey;n!==e.key.id&&(i=!1);const l=r==null?void 0:r.message,m={type:c,addOrUpdate:l,remove:s,clear:o,end:i,sort:h},u={transferList:(r==null?void 0:r.transferList)??[],signal:a};return b(u),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:n,data:m},u)}async _processFeatures(t,e,r,s,i){if(e==null||!e.hasFeatures)return null;const o={transform:t.transform,hasZ:!1,hasM:!1},a=this._factory,c={viewingMode:"",scale:t.scale},n=await this._matchers.feature,h=await this._matchers.aggregate;b(s);const l=this._getLabelInfos(t,e);return await a.analyze(e.getCursor(),this._resourceManagerProxy,n,h,o,c),b(s),this._writeFeatureSet(t,e,o,l,a,r,i)}_writeFeatureSet(t,e,r,s,i,o,a){const c=e.getSize(),n=this._schema.mesh.matcher.symbologyType,h=new U(t.key.id,{features:c,records:c,metrics:0},n,o,n!==L.HEATMAP,a),l={viewingMode:"",scale:t.scale},m=e.getCursor();for(;m.next();)try{const f=m.getDisplayId(),d=s!=null?s.get(f):null;i.writeCursor(h,m,r,l,t.level,d,this._resourceManagerProxy)}catch{}const u=t.tileInfoView.tileInfo.isWrappable;return h.serialize(u)}_handleError(t,e,r){if(!T(e)){const s={tileKey:t.id,error:e.message};return this.remoteClient.invoke("tileRenderer.onTileError",s,{signal:r.signal})}return Promise.resolve()}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(e==null)return null;if(e.type==="subtype"){const s={type:"subtype",classes:{}};let i=!1;for(const o in e.classes){const a=e.classes[o].filter(c=>k(c,t.scale));i=i||!!a.length,s.classes[o]=a}return i?s:null}const r=e.classes.filter(s=>k(s,t.scale));return r.length?{type:"simple",classes:r}:null}_getLabels(t,e){if(e.type==="subtype"){const r=this.service.subtypeField;E(r,"Expected to find subtype Field");const s=t.readAttribute(r);return s==null?[]:e.classes[s]??[]}return e.classes}_getLabelInfos(t,e){const r=this._getLabelingSchemaForScale(t);if(r==null)return null;const s=new Map,i=e.getCursor();for(;i.next();){const o=i.getDisplayId(),a=[],c=$(o),n=c&&i.readAttribute("cluster_count")!==1?"aggregate":"feature",h=this._getLabels(i,r);for(const l of h){if(l.target!==n)continue;const m=i.getStorage(),u=c&&n==="feature"?m.getComputedStringAtIndex(i.readAttribute("referenceId"),l.fieldIndex):m.getComputedStringAtIndex(o,l.fieldIndex);if(!u)continue;const f=P(u.toString()),d=f[0],p=f[1];this._store.getMosaicItem(l.symbol,B(d)).then(g=>{a[l.index]={glyphs:g.glyphMosaicItems??[],rtl:p,index:l.index}})}s.set(o,a)}return s}};S=C([F("esri.views.2d.layers.features.processors.SymbolProcessor")],S);const ke=S;export{ke as default};
